using System;
using System.IO;
using System.Text.Json;
using OpenTK.Mathematics;
using System.Collections.Generic;

namespace DominusCore {
	public class FontAtlas {
		/// <summary> Data storage for each individual character with associated rendering data. </summary>
		public struct Glyph {
			public int Unicode;
			public float Advance;
			public Vector2[] UVs;
			public Vector2 PositionOffset;
			public Vector2 Size;
		}
		private static readonly Dictionary<string, FontAtlas> _loadedFonts = new Dictionary<string, FontAtlas>();

		public readonly Texture AtlasTexture;
		public readonly string FontName;
		public readonly float Size;

		private readonly Glyph[] Glyphs;

		private FontAtlas(Glyph[] glyphs, string fontName, Texture atlasTexture, float size) {
			this.AtlasTexture = atlasTexture;
			this.Glyphs = glyphs;
			this.FontName = fontName;
			this.Size = size;
		}

		/// <summary> Retreives a specified FontAtlas with a given name. Throws an exception if the font is unloaded. </summary>
		public static FontAtlas GetFont(string fontName) {
			if (!_loadedFonts.ContainsKey(fontName))
				throw new Exception($"Unable to find font named {fontName}!");
			return _loadedFonts.GetValueOrDefault(fontName);
		}

		/// <summary> Retreives a specific glyph by it's Unicode ID. Throws an exception if that glyph is null or out of bounds or just not found for any reason. </summary>
		public Glyph GetGlyph(int unicodeID) {
			for (int i = 0; i < Glyphs.Length; i++) {
				if (Glyphs[i].Unicode == unicodeID) {
					return Glyphs[i];
				}
			}
			throw new Exception($"Unable to find glyph {unicodeID} in {FontName}!");
		}

		/// <summary> Loads, processes, and caches a FontAtlas given paths to the MSDF image file and the configuration json generated by MSDFGen-Atlas </summary>
		public static void Load(string font, string fontAtlasPicture, string fontAtlasConfiguration) {
			JsonElement root = JsonDocument.Parse(new StreamReader(fontAtlasConfiguration).ReadToEnd()).RootElement;

			JsonElement atlas = root.GetProperty("atlas");
			float width = (float)atlas.GetProperty("width").GetInt32();
			float height = (float)atlas.GetProperty("height").GetInt32();
			float size = (float)atlas.GetProperty("size").GetDouble();

			// Todo: implement kerning

			JsonElement glyphList = root.GetProperty("glyphs");
			int glyphListSize = glyphList.GetArrayLength();
			Glyph[] glyphs = new Glyph[glyphListSize];
			for (int i = 0; i < glyphListSize; i++) {
				JsonElement glyph = glyphList[i];
				int unicode = glyph.GetProperty("unicode").GetInt32();
				float advance = (float)glyph.GetProperty("advance").GetDouble();

				Glyph currentGlyph = new Glyph();
				currentGlyph.Unicode = unicode;
				currentGlyph.Advance = advance;

				if (unicode != 32) { // Space (unicode id 32) is missing data
					JsonElement planeBounds = glyph.GetProperty("planeBounds");
					float planeBoundsLeft = (float)planeBounds.GetProperty("left").GetDouble();
					float planeBoundsRight = (float)planeBounds.GetProperty("right").GetDouble();
					float planeBoundsBottom = (float)planeBounds.GetProperty("bottom").GetDouble();
					float planeBoundsTop = (float)planeBounds.GetProperty("top").GetDouble();

					JsonElement atlasBounds = glyph.GetProperty("atlasBounds");
					float atlasBoundsLeft = (float)atlasBounds.GetProperty("left").GetDouble();
					float atlasBoundsRight = (float)atlasBounds.GetProperty("right").GetDouble();
					float atlasBoundsBottom = (float)atlasBounds.GetProperty("bottom").GetDouble();
					float atlasBoundsTop = (float)atlasBounds.GetProperty("top").GetDouble();

					currentGlyph.UVs = new Vector2[] {
							new Vector2(atlasBoundsLeft / width, atlasBoundsBottom / height),//2
							new Vector2(atlasBoundsRight / width, atlasBoundsBottom / height),//3
							new Vector2(atlasBoundsLeft / width, atlasBoundsTop / height),//0
							new Vector2(atlasBoundsRight / width, atlasBoundsTop / height),//1
						};
					currentGlyph.PositionOffset = new Vector2(planeBoundsLeft, planeBoundsBottom);
					currentGlyph.Size = new Vector2(planeBoundsRight - planeBoundsLeft, planeBoundsTop - planeBoundsBottom);
				} else {
					currentGlyph.UVs = new Vector2[] {
						new Vector2(0,0),
						new Vector2(0,0),
						new Vector2(0,0),
						new Vector2(0,0)
					};
				}
				glyphs[i] = currentGlyph;
			}
			_loadedFonts.Add(font, new FontAtlas(glyphs, font, Texture.CreateTexture(fontAtlasPicture), size));
			Console.WriteLine($"Font file loaded: {font}");
		}
	}
}
/* 
MSDFGen Atlas's documentation is piss poor and I could only find it in a closed issue from a year ago.
https://github.com/Chlumsky/msdf-atlas-gen/issues/2
Here is a sample json object for each glyph:
{
	"unicode": 76,
	"advance": 0.42041015625,
	"planeBounds": {
		"left": 0.04722414228242527,
		"bottom": -0.03748700427917074,
		"right": 0.4483813264675748,
		"top": 0.6722526292791707
	},
	"atlasBounds": {
		"left": 45.5,
		"bottom": 61.5,
		"right": 58.5,
		"top": 84.5
	}
},
unicode: evident
advance: when creating strings, draw this then move the "cursor" forwards to the left by this
atlasBounds: determines UVs. divide this by atlas.width or atlas.height to get the 4 uv positions
planeBounds: determines where the position of the textured quad is, relative to cursor. 


Kerning:
{
	"unicode1": 65,
	"unicode2": 67,
	"advance": -0.00732421875
},
*/